from GeometricBrownianMotion import GeometricBrownianMotion
import numpy as np
import matplotlib.pyplot as plt
"""
    The functions in this class generate the payoff of Up and Out barrier options
    And check whether the price of the underlying stock is below the barrier level
    The option can no longer be exercised if the Barrier Level is crossed.
    The strike price and payoff of Up and Out barrier options uis similar to a European Call
    
    The main function generates a hundred sample paths of the price an underlying equity
    The final price of each path is used to calculate the payoff of the Up and Out barrier option 
    The payoff is discounted by the risk-free rate to obtain the present value of the option.
    
    This application is another example of how Monte Carlo methods can be used to generate the prices
    of exotic options
"""


class UpandOutBarrierOption:
    def __init__(self, strike, barrier_level):
        self.strike = strike
        self.barrier_level = barrier_level
        self.barrier_trigger = False

    def check_barrier(self, stock_price):
        if stock_price > self.barrier_level:
            self.barrier_trigger = True

    def get_payoff(self, stock_price):
        if not self.barrier_trigger:
            if stock_price > self.strike:
                return stock_price - self.strike
            else:
                return 0
        else:
            return 0


if __name__ == '__main__':
    paths = 100
    initial_price = 100
    drift = .08
    volatility = .3
    dt = 1/365
    T = 1
    price_paths = []

    for _ in range(paths):
        price_paths.append(GeometricBrownianMotion(initial_price, drift, volatility, dt, T).prices)

    barrier_payoffs = []
    risk_free_rate = .01
    for price_path in price_paths:
        # Generate new payoff structure for each path
        bc = UpandOutBarrierOption(100, 100.5)
        for price in price_path:
            bc.check_barrier(price)
        # The last stock price in the series generated by the Geometric Brownian
        # Motion is used to determine the payoff.
        # The risk_free_rate is used to discount the payoff as it received at the
        # end of the year in this example
        barrier_payoffs.append(bc.get_payoff(price_path[-1])/(1+risk_free_rate))

    for price_path in price_paths:
        plt.plot(price_path)

    plt.xlabel("Days", fontsize=15)
    plt.ylabel("Price", fontsize=15)
    plt.title("Simulated Equity Price Paths", fontsize=20)
    plt.show()

    print("Up and Out Barrier option price: " + str(np.mean(barrier_payoffs)*100))
